# PromAI 扩展开发指南

<cite>
**本文档引用的文件**
- [README.md](file://README.md)
- [config.yaml](file://config/config.yaml)
- [collector.go](file://pkg/metrics/collector.go)
- [notify.go](file://pkg\notify\notify.go)
- [generator.go](file://pkg\report\generator.go)
- [main.go](file://main.go)
- [report.html](file://templates\report.html)
- [status.html](file://templates\status.html)
- [cleanup.go](file://pkg\report\cleanup.go)
</cite>

## 目录
1. [概述](#概述)
2. [HTML模板定制](#html模板定制)
3. [监控指标类型扩展](#监控指标类型扩展)
4. [通知渠道扩展](#通知渠道扩展)
5. [代码重构建议](#代码重构建议)
6. [测试方法](#测试方法)
7. [调试技巧](#调试技巧)
8. [社区贡献指南](#社区贡献指南)

## 概述

PromAI是一个基于Prometheus的监控报告自动生成工具，提供了灵活的扩展机制。本指南将指导开发者如何定制和增强PromAI的功能，包括修改HTML模板、添加新的监控指标类型、扩展通知渠道等。

### 主要扩展点
- **HTML模板定制**：修改报告样式和布局
- **监控指标扩展**：添加新的指标类型和查询
- **通知渠道扩展**：支持更多通知方式
- **数据处理扩展**：自定义数据处理逻辑

## HTML模板定制

### 修改报告样式

PromAI使用Go的template包来渲染HTML报告。主要模板文件位于`templates/`目录下。

#### 1. 修改report.html

这是主报告模板，控制整个报告的布局和样式：

```html
<!-- 基本结构 -->
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>{{.Project}}</title>
    <!-- 引入CSS和JavaScript -->
</head>
<body>
    <!-- 报告内容 -->
</body>
</html>
```

**修改步骤：**

1. **调整CSS样式**：
   - 修改颜色方案：编辑`:root`变量定义
   - 调整布局：修改`.container`、`.header`等类的样式
   - 添加自定义样式：在`<style>`标签中添加新的CSS规则

2. **修改布局结构**：
   - 添加新的HTML元素
   - 调整现有元素的顺序
   - 修改数据展示方式

3. **增强交互性**：
   - 添加JavaScript功能
   - 实现动态加载
   - 添加图表库集成

#### 2. 修改status.html

这是健康看板模板，用于显示系统状态：

```html
<!-- 健康看板结构 -->
<div class="header">
    <h1>服务健康看板</h1>
</div>
<div class="summary-cards">
    <!-- 摘要卡片 -->
</div>
<div class="status-table-container">
    <table class="status-table">
        <!-- 状态表格 -->
    </table>
</div>
```

**修改要点：**
- 调整颜色主题变量
- 修改卡片布局和样式
- 优化表格展示效果
- 添加新的状态指标

### 模板函数扩展

在`generator.go`中，可以添加自定义模板函数：

```go
funcMap := template.FuncMap{
    "now": time.Now,
    "date": func(format string, t time.Time) string {
        return t.Format(format)
    },
    // 添加自定义函数
    "formatBytes": formatBytes,
    "extractIP": extractIP,
}
```

**可用的自定义函数：**
- `formatBytes(bytes float64) string`：格式化字节大小
- `extractIP(instance string) string`：提取IP地址
- `getStatusText(status string) string`：获取状态文本

## 监控指标类型扩展

### 添加新的监控指标

#### 1. 修改config.yaml

在`config/config.yaml`中添加新的指标类型：

```yaml
metric_types:
- type: "自定义指标类型"
  metrics:
  - name: "自定义指标名称"
    description: "指标描述"
    query: "prometheus查询表达式"
    trend_query: "趋势查询表达式"
    threshold: 80
    threshold_type: "greater"
    unit: "%"
    labels:
      instance: "实例"
      job: "作业"
```

**配置参数说明：**
- `name`：指标名称
- `description`：指标描述
- `query`：即时查询表达式
- `trend_query`：趋势查询表达式
- `threshold`：阈值
- `threshold_type`：阈值比较类型
- `unit`：单位
- `labels`：标签映射

#### 2. 修改collector.go

确保`collector.go`能够正确解析新的指标类型：

```go
// 在CollectMetrics方法中添加新的指标处理逻辑
for _, metric := range metricType.Metrics {
    // 处理指标查询
    result, _, err := c.Client.Query(ctx, metric.Query, time.Now())
    if err != nil {
        log.Printf("警告: 查询指标 %s 失败: %v", metric.Name, err)
        continue
    }
    
    // 处理查询结果
    switch v := result.(type) {
    case model.Vector:
        // 处理向量结果
        metrics := make([]report.MetricData, 0, len(v))
        for _, sample := range v {
            // 处理样本数据
            labels := make([]report.LabelData, 0, len(metric.Labels))
            for configLabel, configAlias := range metric.Labels {
                // 处理标签
            }
            
            metricData := report.MetricData{
                Name:        metric.Name,
                Description: metric.Description,
                Value:       float64(sample.Value),
                Threshold:   metric.Threshold,
                Unit:        metric.Unit,
                Status:      getStatus(float64(sample.Value), metric.Threshold, metric.ThresholdType),
                Labels:      labels,
            }
            metrics = append(metrics, metricData)
        }
        group.MetricsByName[metric.Name] = metrics
    }
}
```

#### 3. 添加新的阈值类型

在`collector.go`的`getStatus`函数中添加新的阈值比较类型：

```go
func getStatus(value, threshold float64, thresholdType string) string {
    if thresholdType == "" {
        thresholdType = "greater"
    }
    switch thresholdType {
    case "greater":
        // 原有逻辑
    case "custom_new_type":
        // 新的比较逻辑
        if value > threshold {
            return "critical"
        } else if value >= threshold*0.8 {
            return "warning"
        }
    }
    return "normal"
}
```

### 支持新的PromQL查询

#### 1. 添加复杂查询支持

```yaml
- name: "复合指标"
  description: "多个指标的组合"
  query: "sum(rate(http_requests_total[5m])) by (job)"
  trend_query: "sum(rate(http_requests_total[5m])) by (job)[6h:5m]"
  threshold: 100
  threshold_type: "greater"
  unit: "req/s"
```

#### 2. 添加标签过滤

```yaml
- name: "带标签过滤的指标"
  description: "特定标签的指标"
  query: "cpu_usage_percent{job='web-server'}"
  threshold: 80
  threshold_type: "greater"
  unit: "%"
  labels:
    instance: "实例"
    job: "作业"
```

## 通知渠道扩展

### 当前支持的通知渠道

PromAI目前支持以下通知渠道：

1. **钉钉通知** (`DingtalkConfig`)
2. **邮件通知** (`EmailConfig`)
3. **企业微信通知** (`WeComConfig`)

### 扩展新的通知渠道

#### 1. 添加Webhook通知

**步骤1：定义配置结构**

在`notify.go`中添加新的配置结构：

```go
type WebhookConfig struct {
    Enabled   bool   `yaml:"enabled"`
    URL       string `yaml:"url"`
    Headers   map[string]string `yaml:"headers"`
    ReportURL string `yaml:"report_url"`
}
```

**步骤2：添加发送函数**

```go
func SendWebhook(config WebhookConfig, reportPath string) error {
    if !config.Enabled {
        log.Printf("Webhook通知未启用")
        return nil
    }
    
    log.Printf("开始发送Webhook通知...")
    
    // 准备请求数据
    reportFileName := filepath.Base(reportPath)
    reportLink := fmt.Sprintf("%s/reports/%s", config.ReportURL, reportFileName)
    
    // 构造请求体
    requestBody := map[string]interface{}{
        "project": config.ProjectTitle,
        "timestamp": time.Now().Format("2006-01-02 15:04:05"),
        "report": map[string]string{
            "filename": reportFileName,
            "url": reportLink,
        },
    }
    
    jsonData, err := json.Marshal(requestBody)
    if err != nil {
        return fmt.Errorf("JSON编码失败: %v", err)
    }
    
    // 创建HTTP请求
    req, err := http.NewRequest("POST", config.URL, bytes.NewBuffer(jsonData))
    if err != nil {
        return fmt.Errorf("创建请求失败: %v", err)
    }
    
    // 设置请求头
    req.Header.Set("Content-Type", "application/json")
    for key, value := range config.Headers {
        req.Header.Set(key, value)
    }
    
    // 发送请求
    client := &http.Client{}
    resp, err := client.Do(req)
    if err != nil {
        return fmt.Errorf("发送请求失败: %v", err)
    }
    defer resp.Body.Close()
    
    if resp.StatusCode != http.StatusOK {
        return fmt.Errorf("Webhook发送失败，状态码: %d", resp.StatusCode)
    }
    
    log.Printf("Webhook通知发送成功")
    return nil
}
```

**步骤3：在config.yaml中添加配置**

```yaml
notifications:
  webhook:
    enabled: true
    url: "https://your-webhook-url.com/notify"
    headers:
      Authorization: "Bearer your-token"
      Content-Type: "application/json"
    report_url: "http://your-domain.com"
```

**步骤4：在main.go中注册Webhook**

```go
// 在定时任务中添加Webhook通知
if config.Notifications.Webhook.Enabled {
    log.Printf("发送Webhook消息")
    if err := notify.SendWebhook(config.Notifications.Webhook, reportFilePath); err != nil {
        log.Printf("发送Webhook消息失败: %v", err)
    }
}
```

#### 2. 添加飞书通知

**步骤1：定义配置结构**

```go
type FeishuConfig struct {
    Enabled   bool   `yaml:"enabled"`
    Webhook   string `yaml:"webhook"`
    Secret    string `yaml:"secret"`
    ReportURL string `yaml:"report_url"`
}
```

**步骤2：添加发送函数**

```go
func SendFeishu(config FeishuConfig, reportPath string) error {
    if !config.Enabled {
        log.Printf("飞书通知未启用")
        return nil
    }
    
    log.Printf("开始发送飞书通知...")
    
    // 准备请求数据
    reportFileName := filepath.Base(reportPath)
    reportLink := fmt.Sprintf("%s/reports/%s", config.ReportURL, reportFileName)
    
    // 构造飞书消息
    messageContent := map[string]interface{}{
        "msg_type": "interactive",
        "card": map[string]interface{}{
            "config": map[string]interface{}{
                "wide_screen_mode": true,
            },
            "header": map[string]interface{}{
                "template": "blue",
                "title": map[string]interface{}{
                    "tag": "plain_text",
                    "content": fmt.Sprintf("%s巡检报告已生成", config.ProjectTitle),
                },
            },
            "elements": []interface{}{
                map[string]interface{}{
                    "tag": "div",
                    "fields": []interface{}{
                        map[string]interface{}{
                            "is_short": true,
                            "text": map[string]interface{}{
                                "tag": "lark_md",
                                "content": "**生成时间**\n" + time.Now().Format("2006-01-02 15:04:05"),
                            },
                        },
                        map[string]interface{}{
                            "is_short": true,
                            "text": map[string]interface{}{
                                "tag": "lark_md",
                                "content": "**文件名**\n" + reportFileName,
                            },
                        },
                    },
                },
                map[string]interface{}{
                    "tag": "action",
                    "actions": []interface{}{
                        map[string]interface{}{
                            "tag": "button",
                            "text": map[string]interface{}{
                                "tag": "plain_text",
                                "content": "点击查看报告",
                            },
                            "url": reportLink,
                            "type": "primary",
                        },
                    },
                },
            },
        },
    }
    
    jsonData, err := json.Marshal(messageContent)
    if err != nil {
        return fmt.Errorf("JSON编码失败: %v", err)
    }
    
    // 创建HTTP请求
    req, err := http.NewRequest("POST", config.Webhook, bytes.NewBuffer(jsonData))
    if err != nil {
        return fmt.Errorf("创建请求失败: %v", err)
    }
    req.Header.Set("Content-Type", "application/json")
    
    // 发送请求
    client := &http.Client{}
    resp, err := client.Do(req)
    if err != nil {
        return fmt.Errorf("发送请求失败: %v", err)
    }
    defer resp.Body.Close()
    
    if resp.StatusCode != http.StatusOK {
        return fmt.Errorf("飞书发送失败，状态码: %d", resp.StatusCode)
    }
    
    log.Printf("飞书通知发送成功")
    return nil
}
```

**步骤3：在config.yaml中添加配置**

```yaml
notifications:
  feishu:
    enabled: true
    webhook: "https://open.feishu.cn/open-apis/bot/v2/hook/your-webhook-key"
    secret: "your-secret-key"
    report_url: "http://your-domain.com"
```

**步骤4：在main.go中注册飞书通知**

```go
// 在定时任务中添加飞书通知
if config.Notifications.Feishu.Enabled {
    log.Printf("发送飞书消息")
    if err := notify.SendFeishu(config.Notifications.Feishu, reportFilePath); err != nil {
        log.Printf("发送飞书消息失败: %v", err)
    }
}
```

### 通知渠道最佳实践

#### 1. 错误处理

```go
func SendNotificationWithRetry(config interface{}, reportPath string, sendFunc func(interface{}, string) error) error {
    const maxRetries = 3
    var lastErr error
    
    for i := 0; i < maxRetries; i++ {
        err := sendFunc(config, reportPath)
        if err == nil {
            return nil
        }
        
        lastErr = err
        log.Printf("通知发送失败，重试 %d/%d: %v", i+1, maxRetries, err)
        
        if i < maxRetries-1 {
            time.Sleep(time.Duration(i+1) * time.Second)
        }
    }
    
    return fmt.Errorf("多次重试后仍失败: %v", lastErr)
}
```

#### 2. 异步发送

```go
func SendNotificationAsync(config interface{}, reportPath string, sendFunc func(interface{}, string) error) {
    go func() {
        if err := sendFunc(config, reportPath); err != nil {
            log.Printf("异步通知发送失败: %v", err)
        }
    }()
}
```

## 代码重构建议

### 1. 模块化设计

**重构目标：提高代码可维护性和可扩展性**

```go
// 创建通知接口
type Notifier interface {
    Send(config interface{}, reportPath string) error
}

// 实现钉钉通知
type DingtalkNotifier struct{}

func (n *DingtalkNotifier) Send(config interface{}, reportPath string) error {
    cfg, ok := config.(DingtalkConfig)
    if !ok {
        return fmt.Errorf("无效的钉钉配置")
    }
    return SendDingtalk(cfg, reportPath)
}

// 实现Webhook通知
type WebhookNotifier struct{}

func (n *WebhookNotifier) Send(config interface{}, reportPath string) error {
    cfg, ok := config.(WebhookConfig)
    if !ok {
        return fmt.Errorf("无效的Webhook配置")
    }
    return SendWebhook(cfg, reportPath)
}
```

### 2. 配置管理优化

**创建统一的配置管理器**

```go
type NotificationManager struct {
    notifiers map[string]Notifier
    configs   map[string]interface{}
}

func NewNotificationManager() *NotificationManager {
    return &NotificationManager{
        notifiers: make(map[string]Notifier),
        configs:   make(map[string]interface{}),
    }
}

func (nm *NotificationManager) Register(name string, notifier Notifier, config interface{}) {
    nm.notifiers[name] = notifier
    nm.configs[name] = config
}

func (nm *NotificationManager) Send(name string, reportPath string) error {
    notifier, exists := nm.notifiers[name]
    if !exists {
        return fmt.Errorf("通知器 %s 不存在", name)
    }
    
    config, exists := nm.configs[name]
    if !exists {
        return fmt.Errorf("配置 %s 不存在", name)
    }
    
    return notifier.Send(config, reportPath)
}
```

### 3. 数据处理优化

**创建数据处理器接口**

```go
type DataProcessor interface {
    Process(data *ReportData) error
    GetName() string
}

type ChartDataProcessor struct{}

func (p *ChartDataProcessor) Process(data *ReportData) error {
    // 处理图表数据
    for _, group := range data.MetricGroups {
        chartData := make(map[string][]float64)
        for metricName, metrics := range group.MetricsByName {
            metricKey := fmt.Sprintf("%s_%s", group.Type, metricName)
            chartData[metricKey] = make([]float64, len(metrics))
            for i, metric := range metrics {
                chartData[metricKey][i] = metric.Value
            }
        }
        data.ChartData[group.Type] = template.JS(chartData)
    }
    return nil
}

func (p *ChartDataProcessor) GetName() string {
    return "chart_data_processor"
}
```

## 测试方法

### 1. 单元测试

**创建测试文件**

```go
package notify_test

import (
    "testing"
    "PromAI/pkg/notify"
)

func TestSendDingtalk(t *testing.T) {
    config := notify.DingtalkConfig{
        Enabled:   true,
        Webhook:   "https://oapi.dingtalk.com/robot/send?access_token=test",
        Secret:    "test_secret",
        ReportURL: "http://localhost:8091",
    }
    
    err := notify.SendDingtalk(config, "test_report.html")
    if err != nil {
        t.Errorf("发送钉钉通知失败: %v", err)
    }
}
```

### 2. 集成测试

**创建集成测试**

```go
func TestIntegration(t *testing.T) {
    // 设置测试环境
    config := &config.Config{
        PrometheusURL: "http://localhost:9090",
        Notifications: config.NotificationsConfig{
            Dingtalk: notify.DingtalkConfig{
                Enabled: true,
                Webhook: "https://oapi.dingtalk.com/robot/send?access_token=test",
            },
        },
    }
    
    // 创建测试客户端
    client, err := prometheus.NewClient(config.PrometheusURL)
    if err != nil {
        t.Fatalf("创建Prometheus客户端失败: %v", err)
    }
    
    // 创建收集器
    collector := metrics.NewCollector(client.API, config)
    
    // 收集指标
    data, err := collector.CollectMetrics()
    if err != nil {
        t.Fatalf("收集指标失败: %v", err)
    }
    
    // 生成报告
    reportPath, err := report.GenerateReport(*data)
    if err != nil {
        t.Fatalf("生成报告失败: %v", err)
    }
    
    // 发送通知
    if config.Notifications.Dingtalk.Enabled {
        err = notify.SendDingtalk(config.Notifications.Dingtalk, reportPath)
        if err != nil {
            t.Errorf("发送通知失败: %v", err)
        }
    }
}
```

### 3. 性能测试

**创建性能测试**

```go
func BenchmarkGenerateReport(b *testing.B) {
    // 准备测试数据
    testData := createTestData()
    
    b.ResetTimer()
    for i := 0; i < b.N; i++ {
        _, err := report.GenerateReport(testData)
        if err != nil {
            b.Fatal(err)
        }
    }
}
```

## 调试技巧

### 1. 日志记录

**增强日志记录**

```go
func debugLog(level string, message string, data interface{}) {
    log.Printf("[%s] %s: %+v", level, message, data)
}

func (c *Collector) CollectMetrics() (*report.ReportData, error) {
    ctx := context.Background()
    
    debugLog("DEBUG", "开始收集指标", nil)
    
    data := &report.ReportData{
        Timestamp:    time.Now(),
        MetricGroups: make(map[string]*report.MetricGroup),
        GroupOrder:   make([]string, 0, len(c.config.MetricTypes)),
        ChartData:    make(map[string]template.JS),
        Project:      c.config.ProjectName,
    }
    
    for _, metricType := range c.config.MetricTypes {
        debugLog("INFO", "处理指标类型", metricType.Type)
        
        for _, metric := range metricType.Metrics {
            debugLog("DEBUG", "查询指标", map[string]interface{}{
                "name": metric.Name,
                "query": metric.Query,
            })
            
            result, _, err := c.Client.Query(ctx, metric.Query, time.Now())
            if err != nil {
                debugLog("WARN", "查询指标失败", map[string]interface{}{
                    "name": metric.Name,
                    "error": err,
                })
                continue
            }
            
            debugLog("DEBUG", "查询结果", result)
            // 处理结果...
        }
    }
    
    return data, nil
}
```

### 2. 调试模式

**添加调试模式**

```go
var debugMode bool

func init() {
    debugMode = os.Getenv("PROMAI_DEBUG") == "true"
}

func debugLog(message string, data interface{}) {
    if debugMode {
        log.Printf("[DEBUG] %s: %+v", message, data)
    }
}
```

### 3. 性能分析

**添加性能分析**

```go
func profileMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        start := time.Now()
        
        next.ServeHTTP(w, r)
        
        duration := time.Since(start)
        if duration > time.Second {
            log.Printf("慢请求: %s %s took %v", r.Method, r.URL.Path, duration)
        }
    })
}
```

## 社区贡献指南

### 1. 插件化架构

**创建插件接口**

```go
type Plugin interface {
    Init(config interface{}) error
    GetName() string
    GetVersion() string
    Execute(data *ReportData) error
}

var plugins []Plugin

func RegisterPlugin(plugin Plugin) {
    plugins = append(plugins, plugin)
}

func ExecutePlugins(data *ReportData) error {
    for _, plugin := range plugins {
        if err := plugin.Execute(data); err != nil {
            return fmt.Errorf("插件 %s 执行失败: %v", plugin.GetName(), err)
        }
    }
    return nil
}
```

### 2. 插件开发示例

**创建自定义插件**

```go
type CustomPlugin struct {
    name    string
    version string
    config  interface{}
}

func NewCustomPlugin() *CustomPlugin {
    return &CustomPlugin{
        name:    "custom_plugin",
        version: "1.0.0",
    }
}

func (p *CustomPlugin) Init(config interface{}) error {
    p.config = config
    return nil
}

func (p *CustomPlugin) GetName() string {
    return p.name
}

func (p *CustomPlugin) GetVersion() string {
    return p.version
}

func (p *CustomPlugin) Execute(data *ReportData) error {
    // 自定义插件逻辑
    log.Printf("执行自定义插件: %s", p.name)
    
    // 添加自定义数据
    data.CustomData = map[string]interface{}{
        "plugin_version": p.version,
        "execution_time": time.Now(),
    }
    
    return nil
}
```

### 3. 贡献流程

**贡献步骤：**

1. **Fork项目**
   ```bash
   git clone https://github.com/your-username/PromAI.git
   ```

2. **创建功能分支**
   ```bash
   git checkout -b feature/new-notification-channel
   ```

3. **开发和测试**
   ```bash
   # 开发新功能
   go test ./...
   ```

4. **提交更改**
   ```bash
   git commit -m "feat: 添加新的通知渠道"
   ```

5. **推送并创建PR**
   ```bash
   git push origin feature/new-notification-channel
   ```

### 4. 代码规范

**遵循以下代码规范：**

- 使用Go标准格式化工具
- 编写清晰的注释
- 遵循命名约定
- 添加适当的错误处理
- 编写单元测试

### 5. 文档更新

**更新相关文档：**

- 更新README.md
- 添加配置示例
- 编写使用说明
- 更新API文档

## 结论

本扩展开发指南提供了完整的PromAI功能扩展方法，包括HTML模板定制、监控指标类型扩展、通知渠道扩展等。通过遵循这些指导原则，开发者可以轻松地定制和增强PromAI的功能，满足不同的业务需求。

**关键要点：**
- 模块化设计提高可维护性
- 统一的配置管理简化扩展
- 完善的测试保证质量
- 清晰的调试技巧提升效率
- 社区贡献促进生态发展

希望本指南能够帮助您成功扩展PromAI的功能，为您的监控系统带来更多价值。